Intro to D3
    - https://d3js.org/
    - JavaScript library for visualizing data using web standards.
    - Almost as many stars as React on Github
        - https://github.com/d3/d3
    - Open Source and used by a lot of companies
    - There are a lot of libraries built on D3

Insights into learning D3
    - It can be difficult to learn and understand
    - Try not to use copy and paste code
    - It is not always maintainable/understandable

Data + DOM Manipulation
    - D3 code is split into 2 areas
        - Data Manipulation and DOM manipulation
    - Data Manipulation is where variables declared, datasets set up etc
        - D3 is very good at manipulating data
    - DOM Manipulation
        - A lot of people use D3 to manipulate the page where data is rendered
        - D3.select is similar to using JQuery $ followed by a CSS selector
        - A grouping element operates similar to a div
        - A tranforming is similar to an attribute
        - Binding data to the DOM is the most confusing part of D3
        - D3 uses the enter-exit lifecycle to keep everything up to date
        - D3 daisy-chain semantics, this is just looping through data

Scales
    - They help translate between 2 different spaces
    - They are the most versatile and useful part of the D3 API
        - Most examples will have scales
    - They are a function which maps a domain to a range
        - They take an input dataset and calculate the output data
    - Ordinal scales are easiest as they map directly from a domain to a range
        - This means mapping keys directly to their values
    - Linear scales are more difficult and are used to translate between values and screen position
        - The beginning of the domain maps to the beginning of the range
        - This is also true of the top of the domain
        - There is interpolation of everything that is inbetween
            - This is also true of other scales types
            - It is also possible to go beyond the domain and the scale will try figuring the values
    - Experiment with things rather than know by heart

Layouts
    - These can be thought of as prebuilt calculations
    - They allow you to put in a dataset which will then perform actions automatically
    - There are a lot of layouts available
        - They are the data ie they do not render anything but give the information needed to render something
    - A piechart for example is a layout

Why use React + D3
    - React can help with D3's issues with readability, maintainability etc
    - React is designed to perform declarative rendering
        - This will eliminate worrying about the enter-exit lifecycle
    - Using the alphabetexample.js file (demo only!)
        - The code itself just loops through letters and returns a letter
        - It reshuffles the letters every 1.5 seconds
    - React performs rerendering after changes very well
    - Using the React\D3 approach components become more readable and reusable
    - The example uses histograms which would be difficult to uses as easily under solely D3
        - histogramexamples.js 
        - Even if React is not familiar this file should be easily understandable
    - Code should be as easy to read as possible
        - This is to help all people on a team read and understand it
    - React with SVG
        - SVG -- Scalable Vector Graphics
        - It is an image format which uses XML to describe shapes on screen
        - This makes it easy to use with JSX
        - It is not GPU accelerated so if there are many elements performance can be affected
    - The main takeaway is the React will deal better with the DOM and D3 with properties
    - React wants objects to be stateless whereas D3 object have a lot of internal state
        - Controlled components will be a pure representation of their props

Existing Libraries
    - Always evaluate whether to use an existing library or build a custom on
    - For small static charts use excel or similar
    - For dynamic scalable charts first check to see if one matches your use case 
        - Libraries may not allow for customisation
    - Victory.JS
        - https://formidable.com/open-source/victory/
        - victoryjsdemo.js
        - This reimplements a lot of the D3 API
        - It can be good for when basic charts with no customisation is needed
        - This will automatically add axis and is responsive
        - It will use a self-generated fake dataset if created without one
    - Recharts
        - https://recharts.org/en-US/
        - rechartsexample.js
        - Built using React/D3
        - No longer in beta
        - Again it is easy to use and everything is animated
    - Nivo
        - https://nivo.rocks/
        - React/D3 data visualisation components
        - nivoexample.js
        - There is a lot of features implemented by default
        - A lot of features can be difficult to disable
    - VX
        - https://vx-demo.now.sh/
        - vxexample.js
        - A very flexible library
        - Used by a AirBnB
        - It keeps D3 as the data engine and React as the rendering engine
        - Is the most powerful example and can be difficult to learn

Integrate D3 code into a React Project
    - Using blackbox components
        - This is the simplest approach
        - This is where any D3 code can be taken and wrapped in a React component and added to a React Project
        - An example is using code that creates an axis, this can be difficult if being done from scratch
            - This is because there are a lot of smaller moving parts which can affect the axis
        - d3axiscode.js 
            - D3 code only in the example
        - axisreactexample (folder)
            - Containing both D3 and React code
            - This will make use of the React lifecycle methods
            - D3 will control rendering in the example
            - This is what makes it blackbox as React will no longer control rendering
            - React class components allow for using refs
            - Refs can be used to have a reference to a specific DOM node
    - Higher Order Component (blackbox)
        - Writing the lifecycle methods (componentDidMount, componentDidUpdate) may get tedious
        - hocexample (folder) 
        - A Higher Order Component  is a component that returns other components
            - Components will be taken as arguments and wrapped in additional functionality
        - Example will reuse the barchart example code from previously to demonstrate how to render anything
        - The example code uses D3 v4 whereas the course uses D3 v5
        - There is a difference in data loading functions
            - d3.tsv is a data loading function (Barchart.js)
            - This makes a request to a url and returns tab separated values
            - This is now promises based by default (It was callback)
        - Blackbox components can be problematic when there are many 
            - This is because of the rerendering needed(An expensive operation)
    - Full Feature Integration
        - Blackbox approach uses too much D3 and not enough of the React approach
        - Full Feature Integration will get React to do rendering and D3 to do the data manipulation
        - There will be a scatterplot example built using this approach
        - There are 2 different cases
            - Props don't change, this makes components less flexible but is easier to put in place
            - Props change

Scatterplot App
    - Use create-react-app to to create scatterplot-app folder
        - https://github.com/facebook/create-react-app
        - Creates a react app with a lot of setup already done
    - This app will show the props don't change scenario first
    - To run the app change into the directory and npm start
    - App runs on http://localhost:3000/
    - App function will be in the app.js file
    - Setting up components to accept both x and y inputs allow for changing screen position
    - Having dataviz components in their own file makes navigation through codebase easier
        - This is more useful in large projects
    - Axis can also be added to the scatterplot diagram
        - In this case it was a previously used axis which was reused
    - In the first implementation of the scatterplot there is no update when props change
        - This will be changed by changing the width and height based on how many times it has been clicked
        - In App.js change to a class based component
        - This will have state which will then be changed by using an onClick method to reduce size
            - This will be by 20% on every click (reduced)
        - This will only move the x axis
            - This is because of how componentDidUpdate works
                - This method runs after an update has occurred so stale data is being used
                - If D3 data is changed after rendering it is not going to be rendered until the next update
        - The way around the componentDidUpdate issue is to use the getDerivedStateFromProps lifecycle method
            - This was introduced in React 16.3
            - Firstly move the xScale and yScale into state
            - getDerivedStateFromProps take two parameters, props and state, it is also static
        - If using a large dataset it maybe a good idea to use memoization to avoid perfromance issues
    - Using PureComponent to extend rather than Component will reduce the amount of times getDerivedStateFromProps gets called
        - PureComponent is a little bit cleverer about using getDerivedStateFromProps
    - Using renderProps to give control of what individual data points look like to outside
        - This has been called Inversion Of Control (IOC) or Renderless Components
        - Although the scatterplot knows how to render a scatterplot it does not need to know how to render a data point
        - Datapoint will now be a component itself
        - The Datapoint component will make use of Styled Components
    - 
